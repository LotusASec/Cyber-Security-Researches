# n8n: CVE-2025-68613
**n8n İfade Değerlendirme Mekanizmalarının Güvenlik Analizi: Statik Analiz Sınırları ve Sandbox Atlatma Dinamikleri**
## İfade Motorunun Mimarisi ve Saldırı Yüzeyi
Otomasyon araçlarında ifade motorları, kullanıcı girdisini işlenebilir bir mantığa dönüştürmek amacıyla üç temel katmandan oluşan bir mimari kullanır: **Ayrıştırıcı (Parser), Validasyon (Statik Analiz) ve Yürütme Bağlamı (Execution Context)**. Güvenlik mimarisinin temel amacı, kullanıcının veri işleme yeteneklerini korurken, sunucu kaynaklarına (dosya sistemi, ağ, süreç yönetimi) erişimini kısıtlayan bir izolasyon (sandbox) sağlamaktır.  

Saldırı yüzeyi, bu izolasyonun ihlal edilebildiği noktalarda ortaya çıkıyor. Özellikle Node.js tabanlı yapılarda, yürütme bağlamı içerisindeki nesnelerin prototip zincirleri veya global nesne referansları (örneğin this bağlamı), kısıtlı alandan ana işlem bloğuna (main process) geçiş için bir köprü vazifesi görebiliyor.  

Aslında n8n özelinde incelendiğinde, Expression Evaluation System’in dinamik parametre yönetimi sayesinde normalde farklı akışlarda tasarlanması gereken adımların daha sade bir yapı içerisinde gerçekleştirilebildiği görülmektedir. Bu esneklik, workflow tasarımını kolaylaştırmakla birlikte, arka planda JavaScript kodlarının çalıştırılmasını zorunlu kılmaktadır.  

Expression Evaluation System bu kodları kendi yürütme bağlamı içerisinde değerlendirerek host sistemin dosya sistemi, ağ ve süreç yönetimi gibi kaynaklarına doğrudan erişimi sınırlamayı hedefler. Ancak pratikte ortaya çıkan risk, bu izolasyonun varlığına rağmen yürütme bağlamı içerisinden process nesnesine erişimin mümkün olmasıyla ilişkilidir.  

process nesnesi üzerinden ana modül bağlamına (mainModule) geçiş yapılabilmesi ve buradan modül çözümleme (require) zincirinin tetiklenebilmesi, izolasyon sınırlarının dolaylı olarak aşılmasına olanak tanımaktadır. Bu durum, child_process modülünün doğrudan erişilebilir olmasından ziyade, yürütme bağlamının ana işlem bloğuna bağlanabilen referanslar içermesinden kaynaklanan yapısal bir zafiyet olarak değerlendirilebilir. Sonuç olarak, teorik olarak izole edilmesi hedeflenen bir yürütme ortamı, pratikte tam anlamıyla bir sandbox davranışı sergileyememektedir.  

## Referans Exploit Davranışının Teknik Analizi
Gerçekleştirilen testlerde, sistemin güvenlik katmanlarını aşarak işletim sistemi seviyesinde komut çalıştırılmasını sağlayan temel (baseline) payload şu şekildedir:  
```
JavaScript
{{ (function(){ 
  return this.process.mainModule
    .require('child_process')
    .execSync('pwd')
    .toString() 
})() }}
```
Bu payload’ın başarısı, saldırı vektörünün karakteristiğine dair önemli ipuçları sunmaktadır. Saldırganın yeni bir fonksiyon veya kod bloğu "inşa etmek" (code generation) yerine, sistemde halihazırda var olan this bağlamı üzerinden process nesnesine referans vererek ilerlediği görülmektedir. Kavramsal olarak zararsız bir gösterim, {{ this.process.version }} ifadesi ile sistem sürümünün okunması olabilir; bu durum, herhangi bir yıkıcı etki yaratmadan sandbox izolasyonunu aştığımızı gösterir.  
Bu noktada analitik varsayımımız şudur: **Doğrudan nesne referansı kullanımı (this.process), dinamik kod üretimine (constructor vb.) kıyasla, statik analiz filtreleri tarafından tespit edilmesi daha zor ve "daha az gürültülü" bir yöntemdir.**  
## Statik Analizi Atlatma Yöntemlerinin Değerlendirilmesi
Deneysel süreçte elde edilen veriler, sistemin savunma mekanizmasının AST (Soyut Sözdizimi Ağacı) tabanlı yapısal analiz ve kelime bazlı filtreleme kombinasyonuna dayandığını düşündürmektedir.  
## 1. Başarısız Olan Yaklaşımlar ve Metodolojik Çıkarımlar
Aşağıdaki tabloda özetlenen başarısız denemeler, sistemin özellikle kod üretimi ve fonksiyon yapılandırma girişimlerine karşı duyarlı olduğunu göstermektedir:  
### Tablo 1 - Başarısız / Engellenen Yaklaşımlar
|           Yöntem          |                     Payload Özeti                    | Sonuç / Hata                                                | Olası Neden                                                                                                                       |
|:-------------------------:|:----------------------------------------------------:|-------------------------------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------|
| Constructor (Atob)        | {{ ... "".constructor.constructor(decoded)(); ... }} | HATA: Expression contains invalid constructor function call | Sistemin AST analizi, constructor zinciri üzerinden fonksiyon üretimini bir imza (signature) olarak tanımakta ve engellemektedir. |
| Constructor (Parametreli) | {{ ... "".constructor.constructor(...)(cmd) ... }}   | HATA: Expression contains invalid constructor function call | Parametre yapısının değiştirilmesi, yapısal analizin constructor desenini tespit etmesini engelleyememiştir.                      |
| Eval + Buffer             | {{ eval(Buffer.from(...)) }}                         | HATA                                                        | eval fonksiyonunun kullanımı muhtemelen doğrudan engellenmiş veya Buffer nesnesi ortamda tanınmamıştır.                           |
| Bracket + Buffer          | this[Buffer.from(...)]...                            | NULL DÖNDÜ                                                  | Buffer nesnesinin expression bağlamında tanımlı olmaması, işlemin sessizce sonlanmasına (exception swallowing) neden olmuştur.    |
| Bracket + Atob            | this[atob(...)]...                                   | NULL DÖNDÜ                                                  | atob fonksiyonunun mevcut sandbox ortamında bulunmadığı anlaşılmaktadır.                                                          |

Bu sonuçlar, constructor kullanımının yüksek riskli ve tespit edilebilirliği yüksek bir yöntem olduğunu doğrulamaktadır. Ayrıca, null dönüşleri, sistemin hataları kullanıcıya yansıtmadan yutarak (swallowing) çalışmayı durdurduğuna işaret etmektedir.

## 2. Başarılı Olan Yaklaşımlar ve Erişim Stratejisi
Buna karşın, nesne referanslarına dayalı ve statik analizi zorlaştıran yöntemlerin başarı oranı yüksektir:
### Tablo 2 - Başarılı Yaklaşımlar
|               Yöntem              |                                          Payload Özeti                                         | Sonuç     | Olası Neden                                                                                                                                                    |
|:---------------------------------:|:----------------------------------------------------------------------------------------------:|-----------|----------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Raw Payload                       | {{ this.process.mainModule... }}                                                               | ÇALIŞIYOR | Obfuscation uygulanmamış olsa da, constructor kullanılmadığı için yapısal filtreleri geçmiştir. Ancak process gibi anahtar kelimeler tespit edilebilir.        |
| String.fromCharCode (Tam)         | {{ (function(){ const p = String.fromCharCode(...); return this[p][m][r](cp)[ex]('id') })() }} | ÇALIŞIYOR | Standart JS fonksiyonları kullanılmıştır. Köşeli ayraç (bracket access) kullanımı, statik analizin erişilen özelliği (property) çözümlemesini zorlaştırmıştır. |
| String.fromCharCode (Parametreli) | {{ (function(cmd){...})(String.fromCharCode(...)) }}                                           | ÇALIŞIYOR | eval fonksiyonunun kullanımı muhtemelen doğrudan engellenmiş veya Buffer nesnesi ortamda tanınmamıştır.                                                        |


Gözlemlendiği kadarıyla, String.fromCharCode ile çalışma zamanında string üretimi ve bracket notation kullanımı, statik analizörlerin bağlamı anlamasını engelleyerek en etkili bypass yöntemi olmuştur.

## Statik vs. Gelişmiş Dinamik Tespit
Statik analiz, kodun metin tabanlı içeriğine veya AST yapısına odaklanırken; gelişmiş tespit sistemleri çalışma anındaki davranışları izler. Bazı denemelerde (özellikle karmaşık prompt injection senaryolarında) payload'ın çalışmasına rağmen null dönüşü alınması, sistemde sadece giriş (input) seviyesinde değil, çıkış (egress) veya hata yönetimi seviyesinde de bir denetim mekanizması olabileceğini düşündürmektedir. Bu durum, statik analizi aşan bir payload'ın, runtime seviyesindeki bir anomali (örneğin beklenmeyen bir process spawn işlemi) nedeniyle durdurulmuş veya filtrelenmiş olabileceği ihtimalini güçlendirmektedir.
## Sonuçlar, Savunma Çıkarımları ve Gelecek Çalışmalar
Bu çalışma, n8n üzerindeki zafiyetin (CVE-2025-68613 bağlamında) sömürülebilmesi için saldırganın **Authenticated (Giriş Yapmış)** bir kullanıcı olması gerektiğini göstermektedir. Ancak, "kullanıcı zaten yetkili, zararsızdır" varsayımı, güvenlik açısından kritik bir hatadır. Burada siber güvenlikte en önemli konulardan biri olan kimlik erişim yönetimi öne çıkmaktadır. Ancak bu yazı kapsamında IAM kısmını derinleştirmeyeceğiz. Bir otomasyon kullanıcısının, sandbox izolasyonunu aşarak sistem seviyesinde komut çalıştırabilmesi (RCE), açık bir yetki yükseltme (Privilege Escalation) durumudur.
## Savunma Perspektifi ve Öneriler:
1. **Statik Analizin Yetersizliği:** Deneysel veriler, imza ve anahtar kelime tabanlı kontrollerin (örneğin execSync kelimesini yasaklamak) String.fromCharCode ve benzeri encoding teknikleriyle kolayca aşılabilir. Savunma stratejisi yalnızca girdiye odaklanmamalıdır.
2. **Dinamik Analiz ve Runtime Denetimi:** Güvenlik, kodun neye benzediğine değil, ne yaptığına odaklanmalıdır. child_process, process.binding gibi kritik Node.js modüllerinin çağrıldığı anlar çalışma zamanında (runtime) izlenmelidir.
3. **Kullanıcı Aktivite İzleme:** Otomasyon süreçlerini yöneten kullanıcılar da dahil olmak üzere, sistemdeki tüm aktiviteler monitör edilmelidir. Anormal process türetme (spawning) aktiviteleri, davranışsal analiz araçlarıyla tespit edilmelidir. Burada yüksek hacimli log dosyalarıyla uğraşılacağı için ince bir ayar vardır, neyin loglnacağı ve neyin izleneceği kısmında bu ince nüans her ortamın kendi yapısına göre değişir.
4. **Siber Hijyen ve Güncelleme:** En temel ve etkili savunma, etkilenen sistemlerin 1.120.4 veya üzeri bir sürüme güncellenmesidir. Bu geçişin kontrollü bir şekilde yapılmalıdır. Aksi takdirde Crowdstrike in 19.07.2024 de sebep olduğu küresel kesinti gibi durumlara karşı açık kapı bırakmış oluruz. Burasıda vulnrubility and patch management dediğimiz ayrı bir konu gündeme gelmektedir. Ayrıca, "en az yetki" (least privilege) prensibi gereği, otomasyon servislerini çalıştıran kullanıcıların işletim sistemi üzerindeki yetkileri minimize edilmelidir.
5. 
Sonuç olarak; sistemin olgunluğu ne olursa olsun, dilin dinamik yapısı (JavaScript) statik bariyerlerin etrafından dolaşılmasına imkan tanıyabilmektedir. Bu nedenle güvenlik, tek seferlik bir önlem değil, sürekli izleme, tespit ve iyileştirme gerektiren bir süreç olarak ele alınmalıdır.	
